using UnityEngine;
using UnityEngine.UI;
using System.Linq;

/// <summary>
/// gif图一帧的数据，图像和延迟时间
/// </summary>
public struct GifFrame
{
    public Sprite sprite;
    /// <summary>
    /// 以秒为单位
    /// </summary>
    public float delay;
}

/// <summary>
/// gif数据，所有的帧
/// </summary>
public struct GifData
{
    public GifFrame[] frames;
}

[RequireComponent(typeof(Image))]
public class ImagePlayer : MonoBehaviour
{
    Image _imageComponent;
    GifData _gifData;
    float[] _nextFrameTime;
    float _playTime;


    public void SetImage(GifData gif)
    {
        if (gif.frames == null || gif.frames.Length == 0 || gif.frames[0].sprite == null)
            NoFrame();
        else if (gif.frames.Length == 1)
            OneFrame(gif);
        else
            MultipleFrames(gif);
    }
    public void SetImage(Sprite sprite)
    {
        SetImage(new GifData { frames = new GifFrame[] { new GifFrame { sprite = sprite, delay = 0 } } });
        /*
        * 上面那行拆开是这样的
        new GifData                     //创建 GifData
        {
            frames = new GifFrame[]     //给这个 GifData 的 frames 赋一个 GifFrame数组
            {
                new GifFrame            //给这个 GifFrame数组 创建一个 GifFrame对象
                {
                    sprite = sprite,    //把参数 Sprite 赋给这个 GifFrame对象 的 sprite 属性
                    delay = 0           //间隔写0就行
                }
            }
        };
        */
    }

    void NoFrame()
    {
        _imageComponent.sprite = null;

        Stop();
    }

    void OneFrame(GifData gif)
    {
        _imageComponent.sprite = gif.frames[0].sprite;

        Stop();
    }

    void MultipleFrames(GifData gif)
    {
        _gifData = gif;

        ComputeNextFrameTimeArray(gif);

        ToBegin();
        Play();
    }
    void ComputeNextFrameTimeArray(GifData gif)
    {
        _nextFrameTime = new float[gif.frames.Length];
        float nextFrameTime = 0;

        int frameCount = gif.frames.Length;
        for (int i = 0; i < frameCount; i++)
        {
            nextFrameTime += gif.frames[i].delay;
            _nextFrameTime[i] = nextFrameTime;
        }
    }





    public void Play()         //这个方法有缺陷：如果在运行期间播放基本确定不会从第一帧开始播放，需要加一个偏转值
    {
        enabled = true;
    }

    public void Pause()
    {
        enabled = false;
    }

    public void Stop()
    {
        enabled = false;

        ToBegin();
    }

    public void CleanData()
    {
        _gifData.frames = null;
        _nextFrameTime = null;
        ToBegin();
    }

    void ToBegin()
    {
        _playTime = 0;
    }





    private void Awake()
    {
        _imageComponent = GetComponent<Image>();

        Stop();     //刚开始是没有数据的，自动Stop
    }

    private void Update()
    {
        //Debug.Log("15.2 % 2.5 = " + (15.2 % 2.5));    //输出是 0.5，这一步可以看出C#的取余规则不要求必须整数，取余只取到不能整除的部分
        _playTime += Time.deltaTime;
        UpdateGifFrame();
    }

    void UpdateGifFrame()
    {
        _imageComponent.sprite = GetCurrentSprite();
    }
    Sprite GetCurrentSprite()
    {
        float frameTime = (_playTime) % _nextFrameTime.Last();   //下一帧时间的最后一个数就是全部播放完的时间      偏转时间的加减号还需要研究

        int framesCount = _gifData.frames.Length;
        for (int i = 0; i < framesCount; i++)
            if (frameTime < _nextFrameTime[i])          //时间小于下一帧时间，也就是说就在这一帧了
                return _gifData.frames[i].sprite;

        return _gifData.frames[0].sprite;       //一般来说应该到不了这，但如果真的到了，应该是时间超过最后一帧了，返回第一帧
    }
}
